---
title: Intel x86 汇编语言
date: 2021-03-26
updated: 2021-10-29
toc: true
mathjax: false
categories:
  - [杂货铺]
tags:
  - 汇编
---


> 文章参考自[x86 Assembly Guide](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)  
> 这篇文章只是个人的理解翻译，方便日后参考使用  
> 详情请参见原文

### 前言
学习计算机组成原理有助于理解本文

一些资源
- [在 Visual Studio 使用汇编](http://www.cs.virginia.edu/~evans/cs216/guides/vsasm.html)
- [Intel x86 汇编指令集参考](http://www.felixcloutier.com/x86/)
- [Intel Pentium 手册](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)


### 寄存器
现代 x86 处理器中，有 8 个通用寄存器，在历史上，它们按照不同的用途命名  
如 `EAX` 叫做“累加器”，因为它常被用作加法计算  
在现代，尽管它们并没有什么区别，但习惯上仍沿用历史的做法  
对于 32 位的 `EAX`、`EBX`、`ECX`、`EDX`  
我们也可以单独访问它们的低 16 位或者更低的位数  
如 `EAX` ，通过  
- `AX` 可访问低 16 位(0~15)
- `AH` 可访问低 16 位中的高 8 位(8~15)
- `AL` 可访问低 16 中的低 8 位(0~7)

**E** 是 **Extended**，即 **拓展** 的意思  
说明 `EAX`(32位) 是 `AX`(16位) 的拓展

**X** 其实也是 **拓展** 的意思  
但它是指从 `AL`(8位) 拓展到 `AX`(16位)

**8 个寄存器的名称**
- `EAX`(accumulator): 累加寄存器
- `EBX`(base): 基址寄存器
- `ECX`(counter): 计数寄存器
- `EDX`(data): 数据寄存器
- `ESI`(source index): 源变址寄存器
- `EDI`(destination index): 目的变址寄存器
- `ESP`(stack pointer): 栈指针寄存器
- `EBP`(base pointer): 基址指针寄存器


### 内存与寻址模式
寻址模式可分为：
直接寻找、间接寻址、变址寻址

**直接寻址**：给出的地址是存放的是 **数据**  
**间接寻址**：给出的地址是存放的是 **数据的地址**  
**变址寻址**：给出的地址作为基准，使用偏移得到数据的真实地址，进而得到数据

#### 内存寻址
使用 `[]` 表示进行寻址  
即: 如 `[eax]` 指的是将 `eax` 中存储的数据作为内存地址  
随后读取该内存地址中存储的数据，这属于寄存器间接寻址

现在简单介绍 `mov` 指令，并使用它在寄存器与内存间传递数据  
`mov` 指令有两个参数，第一个参数为目的地，第二个是数据源

**例子**
```
mov     eax, [ebx]              ; 将 EBX 中存储的数据作为内存地址，将内存地址中的数据存入EAX
mov     [var], ebx              ; 将 var 中存储的数据作为内存地址，将 EBX 中的数据存入内存地址
mov     eax, [esi - 4]          ; 将 ESI 中存储的数据加上 -4 作为内存地址，将内存地址中的数据存入 EAX
mov     [esi + eax], cl         ; 将 ESI 与 EAX 中的数据相加作为内存地址，将 CL 中存储的数据存入内存地址
mov     edx, [esi + 4 * ebx]    ; 将 ESI 中存储的数据加上 (EBX 中的数据 * 4) 作为内存地址，将内存地址中的数据存入 EDX
```

注意，以下语法是 ***错误的***
```
mov     eax, [ebx - ecx]            ; 寄存器间只能相加
mov     [eax + esi + edi], ebx      ; 最多只能有两个寄存器相加
```

### 声明静态数据区域与数据
使用 `.DATA` 声明一块数据区域，并在此区域声明静态数据

#### 声明数据
数据可以被给予一个“名字”，如 “var”，这个“名字”代表的其实是此数据在内存中的地址
`DB`(declare byte)可以声明 1 字节的数据
`DW`(declare word)可以声明 2 字节的数据
`DD`(declare dobute word)可以声明 4 字节的数据

**例子**
```
.DATA
    var     DB  64      ; 声明一个 1 字节，名为 var，值为 64 的数据
    var2    DB  ?       ; 声明一个 1 字节，名为 var2，值未初始化的数据
            DB  10      ; 声明一个 1 字节，没有名字，使用 [var2 + 1] 访问，值为 10 的数据
    X       DW  ?       ; 声明一个 2 字节，名为 X，值未初始化的数据
    Y       DD  30000   ; 声明一个 2 字节，名为 Y，值为 30000 的数据
```

#### 指定数据大小
通常来说，数据大小能从给出的寄存器判断得出，例如 `AX` 即指 16 位数据，也就是 2 字节  
但在一些情况下无法判断数据大小，如 `mov  [eax], 2`, 这种情况下不能明确知道数据的大小  
因此需要在指令中指定数据大小，使用方法如下：  
`BYTE PTR` 指定 1 字节大小  
`WORD PTR` 指定 2 字节大小  
`DWORD PTR` 指定 4 字节大小

**例子**
```
mov     BYTE PTR    [ebx], 2    ; 将数据 2 储存到由 ebx 指出的内存地址中。大小为 1 字节
mov     WORD PTR    [ebx], 2    ; 将数据 2 储存到由 ebx 指出的内存地址中。大小为 2 字节
mov     DWORD PTR   [ebx], 2    ; 将数据 2 储存到由 ebx 指出的内存地址中。大小为 4 字节
```

#### 声明数组
不像高级编程语言，汇编语言不能按照 *下标* 对数组进行索引，只能通过 *偏移* 的方式定位数据  
在汇编中，数组内的所有数据在一块连续的区域，可通过 *基址寻址* 的方式寻找数据  
数组可以通过 *列出连续的数据* 来声明，或者通过 `DUP` 指令 *创建连续的数据* 进行声明  
`DUP` 指令告诉汇编器以指定的次数重复地列出一个数据，例如 `3 DUP(2)` 意味着 `2, 2, 2`

**例子**
```
.DATA
    Z       DD  1, 2, 3     ; 声明一个具有 3 个 4 字节元素，名为 Z 的数组，值分别为 1, 2 和 3，位于 Z + 8 地址上的值是 3
    bytes   DB  10  DUP(?)  ; 声明一个具有 10 个 1 字节元素，名为 bytes 的数组，值未初始化
    arr     DD  100 DUP(0)  ; 声明一个具有 100 个 4 字节元素，名为 arr 的数组，值初始化为 0
    str     DB  'hello',0   ; 声明一个具有 6 个 1 字节元素，名为 arr 的数组，值初始化为 ‘hello’ 的 ASCII 字符编码，以及 0
```

### 指令
指令一般由操作码与操作数组成，其中操作数可以有多个，也有部分指令没有操作数  
指令可分为：数据转移指令、算术运算与逻辑指令、流程控制指令三类  
约定在下文中，使用特定的格式表述不同位数的寄存器、数据、以及内存等  
约定如下：  
`<reg32>`   32位寄存器，如 `EAX`、`EBX`、`ECX`、`EDX`、`ESI`、`EDI`、`EBP`  
`<reg16>`   16位寄存器，如 `AX`、`BX`、`CX`、`DX`  
`<reg8>`    8位寄存器。如 `AH`、`AL`、`BH`、`BL`、`CH`、`CL`、`DH`、`DL`  
`<mem>`     内存，如 `[eax]`、`[var + 4]`  
`<con32>`   32位常量（4 字节）  
`<con16>`   32位常量（2 字节）  
`<con8>`    32位常量（1 字节）  
`<con>`     任意位数常量

#### 数据转移指令

##### `mov` 指令
Move (操作码：88, 89, 8A, 8B, 8C, 8E, ...)  
`mov` 指令将它第二个操作数声明的数据复制到第一个操作数指定的位置  
这个位置可以是内存或者寄存器

**用法**
```
mov     <reg>, <reg>
mov     <reg>, <mem>
mov     <mem>, <reg>
mov     <reg>, <con>
mov     <mem>, <con>
```

**例子**
```
mov     eax, ebx                ; 将 ebx 中的数据复制到 eax
mov     byte ptr    [var], 5    ; 将 5 赋值给名为 var 的变量
```

##### `push` 指令
压入栈 Push stack (操作码：FF, 89, 8A, 8B, 8C, 8E, ...)  
`push` 指令将它的操作数压入栈堆，存储在特定的寄存器中（一般是存储在 `ESP`）  
`push` 首先将 `ESP` 中的数据减去 4，随后将操作数存储到 `ESP` 指向的内存地址中  
注：栈里的数据存储在内存中，寄存器 `ESP` 存储的是内存地址，栈在内存中从高地址向低地址增长

**用法**
```
push    <reg32>
push    <mem>
push    <con32>
```

**例子**
```
push    eax     ; 将 EAX 中的数据压入栈
push    [var]   ; 将名为 var 的变量的值压入栈
```

##### `pop` 指令
弹出栈 Pop stack  
`pop` 指令将特定寄存器的值（一般是 `ESP`）弹出，存储到它的操作数指定的位置  
`pop` 首先读取位于由 `ESP` 给出的内存地址中的值，将其存入到操作数指定的位置  
随后将 `ESP` 的值加 4

**用法**
```
pop     <reg32>
pop     <mem>
```

**例子**
```
pop     edi     ; 将栈顶数据弹出，存储到 EDI
pop     [ebx]   ; 将栈顶数据弹出，存储到由 EBX 给出的内存地址中
```

##### `lea` 指令
取地址 load effective address  
`lea` 指令将第二操作数的有效地址存入第一个操作数给定的寄存器中  
`lea` 与 `mov` 并不同，`mov` 是将第二操作数给定的数据存入第一操作数给定的位置  
而 `lea` 是将数据的地址存入第一操作数给定的寄存器

**语法**
```
lea     <reg32>, <mem>
```

**例子**
```
lea     edi, [ebx + 4*esi]      ; EBX + 4*ESI 的值作为地址存入 EDI
lea     eax, [var]              ; var 代表的地址存入 EAX
```

#### 算术运算与逻辑指令

##### `add` 指令
`add` 指令将它的两个操作数的值相加，并将结果存储到第一个操作数指定的位置中  
注意，操作数可以是两个寄存器，但最多只能有一个是内存地址

**用法**
```
add     <reg>, <reg>
add     <reg>, <mem>
add     <mem>, <reg>
add     <reg>, <con>
add     <mem>, <con>
```

**例子**
```
add     eax, 10                     ; eax = eax + 10
add     byte ptr [var], 10          ; var = var + 10
```

##### `sub` 指令
与 `add` 指令相似，`sub` 指令将第一个操作数的值减去第二个操作数，结果保存在第一个操作数

**用法**
```
sub     <reg>, <reg>
sub     <reg>, <mem>
sub     <mem>, <reg>
sub     <reg>, <con>
sub     <mem>, <con>
```

**例子**
```
sub     al, ah      ; AL = AL - AH
sub     eax, 216    ; 将 EAX 中的值减去 216，结果保存在 EAX
```

##### `inc` 与 `dec` 指令
`inc` 指令将操作数的值增加 1 （自增）
`dec` 指令将操作数的值减少 1 （自减）

**用法**
```
inc     <reg>
inc     <mem>
dec     <reg>
dec     <mem>
```

**例子**
```
inc     eax                 ; 将 EAX 中的值自增 1，结果存入 EAX
dec     DWORD PTR   [var]   ; 将 var 中的 32 位的值自减 1，结果存入 var （代表的地址）
```

##### `imul` 指令
整数相乘 Integer Multiplication  
`imul` 指令有两种基本的格式，分别为 *带 2 个操作数*、*带 3 个操作数*  
- 带 2 个操作数时，将两个操作数相乘，结果存入第一个操作数处  
- 带 3 个操作数时，将第 3 个和第 2 个操作数相乘，结果存入第一个操作数处

**用法**
```
imul    <reg32>, <reg32>
imul    <reg32>, <mem>
imul    <reg32>, <reg32>, <con>
imul    <reg32>, <mem>, <con>
```

**例子**
```
imul    eax, [var]      ; 将 var 的值与 EAX 的值相乘，结果存入 EAX
imul    esi, edi, 25    ; 将 EDI 的值与 25 相乘，结果存入 ESI
```

##### `idiv` 指令
`idiv` 指令将给出的操作数除以存储在 EDX:EAX 的 64 位的整数  
EDX 中的值作为高四位，EAX 中的值作为低四位  
得到的商存储在 EAX 中，余数存储在 EDX 中

**用法**
```
idiv    <reg32>
idiv    <mem>
```

**例子**
```
idiv    ebx                 ; 将 EBX 中的值除以 EDX:EAX，商存在 EAX，余数存在 EDX
idiv    DWORD PTR [var]     ; 将存在 var 表示内存地址中的 32 位的值除以 EDX:EAX，商存在 EAX，余数存在 EDX
```

##### `and`, `or`, `xor` 指令
这些指令分别是将两个操作数进行*按位与*，*按位或*，*按位异或*操作  
得到的结果存在第一个操作数

**用法**
```
and     <reg>, <reg>
and     <reg>, <mem>
and     <mem>, <reg>
and     <reg>, <con>
and     <mem>, <con>

or      <reg>, <reg>
or      <reg>, <mem>
or      <mem>, <reg>
or      <reg>, <con>
or      <mem>, <con>

xor     <reg>, <reg>
xor     <reg>, <mem>
xor     <mem>, <reg>
xor     <reg>, <con>
xor     <mem>, <con>
```

**例子**
```
and     EAX, 0fH    ; 只保留 EAX 的低 4 位
xor     EDX, EDX    ; 将 EDX 所有位置 0
```

##### `not` 指令
进行按位取反操作

**用法**
```
not     <reg>
not     <mem>
```

**例子**
```
not     BYTE PTR [var]      ; 将 var 地址处的值按位取反
```

##### `neg` 指令
对操作数内容的二进制补码进行按位取反操作

**用法**
```
neg     <reg>
neg     <mem>
```

**例子**
```
neg     EAX         ; 将得到 -EAX
```

##### `shl`, `shr` 指令
左移右移指令  
将第一个操作数进行左移或者右移，用 0 填充空位，最多移动 31 位  
移动的位数由第二个操作数决定，第二个操作数可以是 8 位常量或者是 CL 寄存器  
若移动位数大于 31，则按照以 32 为模得出的值进行移位

**用法**
```
shl     <reg>,<con8>
shl     <mem>,<con8>
shl     <reg>, CL
shl     <mem>, CL

shr     <reg>,<con8>
shr     <mem>,<con8>
shr     <reg>, CL
shr     <mem>, CL
```

**例子**
```
shl     EAX, 1          ; 将 EAX 乘以 2
shr     EBX, CL         ; 将 EBX 除以 2n, 其中 n 是 CL 的值
```



#### 流程控制
x86 处理器有一个指令寄存器 (instruction pointer register)(IP)  
这是一个 32 位的寄存器，保存当前执行的指令在内存中的起始地址  
通常来说，它每执行一个指令后会自增，以指向下一个指令的起始地址  
指令寄存器不能被直接更改 [^ctrl-flow-1]，但可以通过流程控制指令进行更新

[^ctrl-flow-1]: 指不能通过赋值的方式修改

在这里约定一个新的符号 `<lable>`，它用来表示汇编代码中的一个标签  
如，在下面的代码中：
```
        mov     ESI, [EBP + 8]
begin:  xor     ECX, ECX
        mov     EAX, [ESI]
```
`begin` 是一个 `<lable>`  
实际上这个标签是一个代表地址的符号，与变量 `var` 类似  
但标签代表的是指令的地址，而变量代表的是数据的地址  
可以在代码的其他位置使用这个标签来获得标签表示的地址

在下面的示例中并不会特别指出 `<lable>` 所代表的指令  
只说明各跳转指令的用法

##### `jmp` 指令
无条件跳转指令  
无条件地将程序控制流跳转到操作数指示的位置处

**用法**
```
jmp     <lable>
```

**例子**
```
jmp     begin       ; 跳转到 begin 处
```

##### 条件跳转指令

这是一个统称，代表着一系列根据不同条件判断是否进行跳转的指令  
如果符合条件，则会执行跳转，否则将按原来的流程继续执行下一条指令

条件跳转指令的条件来自最后执行算术运算的信息，如：结果是否为零  
这些信息保存在一个特殊的寄存器中，称作状态寄存器 [^jc-1] (machine status word)

[^jc-1]: 或者叫做*程序状态字*

许多指令的转移条件可以根据上一次执行的操作直观地得出  
这个操作指的是特殊的比较指令 `cmp` （在下文有说明）  
例如：`jle` 和 `jne` 依赖于 `cmp` 指令对操作数的执行结果  
因此，条件转移指令通常会和 `cmp` 指令一起使用

**用法**
```
je      <lable>     ; 相等时跳转
jne     <lable>     ; 不相等时跳转
jz      <lable>     ; 结果为 0 时跳转
jg      <lable>     ; 大于时跳转
jge     <lable>     ; 大于或等于时跳转
jl      <lable>     ; 小于是跳转
jle     <lable>     ; 小于或等于时跳转
```

**例子**
```
cmp     EAX, EBX
jle     done        ; 如果 EAX 小于或者等于 EBX，则跳转至 done 处
mov     EAX, EBX    ; 否则继续执行下一条指令，也就是这一行的指令
```

##### `cmp` 指令
将给出的两个操作数进行对比，并更新状态寄存器  
`cmp` 指令等效于 `sub` 指令，唯一区别则在于  
`cmp` 指令会将结果丢弃而不是存入第一个操作数

**用法**
```
cmp     <reg>, <reg>
cmp     <reg>, <mem>
cmp     <mem>, <reg>
cmp     <reg>, <con>
```

**例子**
```
cmp     DWORD PTR [var], 10
jeq     loop
; 如果 var 的值等于 10，则会跳转到 loop
; 否则执行下一条指令
```

##### `call`, `ret` 指令
这两个指令实现了子程序的调用与返回  
`call` 指令会先将当前代码的位置压入堆栈，然后无条件跳转到标签处  
与简单的 `jmp` 指令不同，`call` 指令会保存子程序完成时应返回的位置

`ret` 实现从子程序中的返回  
它首先将在堆栈中的地址弹出，然后无条件跳转到此地址  
子程序返回后则继续执行下一条指令

**用法**
```
; call 用法
call    <lable>

; ret 用法
ret
```

**例子**
```
callme: xor     EAX, EAX
        ret                 ; 返回到调用处
call    callme              ; 调用 callme
        xor     EBX, EBX    ; 返回后继续执行指令
```


### 调用约定
调用约定是为了使程序员之间能够共享代码并开发可以供许多程序使用的库，并简化子程序的使用  
是一组约定如何调用以及如何返回的协议  
在给定规则的情况下，程序员无需了解子程序的定义，只需按照约定进行调用即可  
并且，可以使高级语言的汇编器遵从约定，使得手工编写的汇编代码能够调用高级语言编写的函数

最为广泛使用的是 C 语言的调用约定  
遵从这个约定，我们可以调用定义在 C 或者 C++ 程序里的函数  
并且还能够调用 C 的库函数

C 调用约定很大程度上基于硬件支持堆栈的使用  
它基于 `push`、`pop`、`call` 和 `ret` 指令，子程序参数在堆栈上传递  
寄存器保存在栈上，子程序使用的局部变量放在栈上的内存中  
在大多数处理器上实现的绝大多数高级过程语言使用都使用类似的调用约定

调用约定分为两组，一组规则由调用者使用，另一组由被调用者  
注意：  
在调用期间发生的错误会导致严重的程序错误，因为这会使堆栈处于不确定的状态


示意图：
```
      栈增长方向
+------------------+
| saved ESI        | <--- ESP
+------------------+
| saved EDI        |
+------------------+
| local variable 3 |
+------------------+
| local variable 2 |
+------------------+
| local variable 1 | <--- EBP - 4
+------------------+
| saved EBP        | <--- EBP
+------------------+
| return address   |
+------------------+
| parameter 1      | <--- EBP + 8
+------------------+
| parameter 2      | <--- EBP + 12
+------------------+
| parameter 3      | <--- EBP + 16
+------------------+
      高地址方向
```

在上面的示意图中，调用者向子程序传递了 3 个参数 `parameter 1 - 3`  
子程序有三个自己的局部变量 `local variable 1 - 3`  
堆栈中每个单元是 32 位宽的内存位置，故相邻的单元格相隔 4 个字节  
传入子程序的第一个参数位置在 EBP 偏移 8 个字节的偏移处  
在传入参数的上方与基指针（图中EBP）的下方是返回地址  
当使用 `ret` 指令从子程序返回时，会跳转至这个返回地址

#### 调用方规则
为了进行调用，调用方应该：
1. 调用前，调用方应该保存 EAX, ECX, EDX 这些*调用方保存寄存器* [^caller-rules-1] 的值  
   因为子程序能够更改这些寄存器的值  
   如果调用方需要在子程序返回后继续使用这些值，那么调用方必须将这些值压入栈  
   以便在子程序返回后恢复这些值
2. 在调用前将参数压入栈，以传递给子程序使用  
   应以相反的顺序将参数压入栈，如：最后一个参数应第一个压入栈  
   因为栈遵从先进后出原则，所以第一个参数处于低地址处 [^caller-rules-2]  
   这种参数倒置的方式在历史上被用于允许函数传递可变数量的参数
3. 使用 `call` 指令调用子程序  
   这个指令会先将返回的地址压入堆栈，然后切换到子程序执行指令

[^caller-rules-1]: 这些寄存器被称作 caller-saved 寄存器

[^caller-rules-2]: 在内存中, 栈从高地址向低地址增长

在子程序返回后，调用方能从 EAX 寄存器中获得子程序的返回值  
为了将程序恢复到调用前的状态，调用方此时应该：  
1. 从栈中移除传递的参数，将栈恢复到调用前的状态
2. 将存储在栈中的寄存器（EAX, ECX, EDX）的值弹出，以恢复这些寄存器在调用前的值  
   调用方可以假设没有其他寄存器被子程序修改

**例子**
下面的代码是一个简单的调用方的示例  
调用方调用了一个名为 *_myFunc* 的函数，这个函数需要传递三个整数型参数：
- 第一个参数存储在 EAX 寄存器
- 第二个参数是常量 216
- 第三个参数是存储在内存地址 *var* 中的值

```
push    [var]           ; 传递第三个参数
push    216             ; 传递第二个参数
push    EAX             ; 传递第一个参数

call    _myFunc         ; 调用子程序

add     ESP, 12         ; 清理传入的参数
```

> 注意：从子程序返回后，EBP 的值也恢复到了 *saved EBP* （见上方的示意图）表示的值  
> ESP 则指向 *return address* 处

在代码的最后，使用了 `add` 指令修改了 ESP 的值，这是为了清理传入的参数  
在上面提到，一个单元格为 32 位，即 4 字节  
我们传入了 3 个参数，使用了 3 * 4 = 12 字节  
因此我们需要将栈顶指针恢复到 ESP + 12 处

现在可以通过 EAX 来获取子程序的返回值

如果调用方还需要原本 EAX, ECX, EDX 的值  
那么则应该在调用前将这些值存入栈  
并在子程序返回之后恢复这些值

#### 被调用方规则

下面的规则应用于子程序入口处
1. 使用下列的指令将 EBP 压入栈，并且将 ESP 的值复制到 EBP
   ```
   push     EBP
   mov      EBP, ESP
   ```
2. 然后，为局部变量分配栈空间，即使用 `push` 指令将局部变量压入栈  
   再次说明，栈往内存地址的低地址方向增长，所以为了获得空闲的内存区域  
   栈顶指针应该减去值，应该减去的值由局部变量的数量与大小决定  
   比如，如果有 3 个*整型*的局部变量，那么栈顶指针应该减去 3 * 4 = 12  
   以获得足够的内存空间用于存储局部变量  
   和参数相同一样，局部变量也能通过基于基指针的偏移获得
3. 然后，保存一些*被调用方保存寄存器* [^callee-rules-1] 的值  
   因为这些寄存器的值可能会被修改  
   因此，使用 `push` 将它们的值保存在栈中，这些寄存器是 EBX, EDI 和 ESI  
   ESP 和 EBP 也属于这些寄存器的一部分，但它们在一开始（规则 1）就被保存了

[^callee-rules-1]: 这些寄存器被称作 "callee-saved registers"

在完成上述 3 个规则的步骤后，子程序即可进行自己的流程  
当子程序需要返回时，它应该遵从下方的规则

1. 将返回值保存至 EAX
2. 恢复被修改过的*被调用方保存寄存器*的值，通过 `pop` 指令将它们从栈中取出并恢复  
   取出的顺序应和它们保存时的顺序相反（栈的先进后出原则）
3. 删除局部变量，一个直接的方法即给栈顶指针加上在*分配过程中减去的值* [^callee-rules-2]  
   但是最不容易出错的方式是将基指针的值移动到栈顶指针中 `mov   ESP, EBP`  
   这是因为基指针的值永远是*在即将分配局部变量前*的栈顶指针的值
4. 在即将返回前，使用 `pop` 指令恢复先前保存在栈中的旧的 EBP 的值  
   这是属于调用方的 EBP，弹出 EBP 后，此时 ESP 指向返回地址
5. 最后调用 `ret` 指令  
   这个指令会读取 ESP 指向的返回的地址，将其地址存入指令寄存器，在返回后会删除此地址

[^callee-rules-2]: 即在子程序入口出的规则 2 中减去的值

注意，被调用者的规则完全分为两半，它们基本上是彼此的镜像  
规则的前半部分适用于子程序的开头，通常被称为定义子程序的序言  
规则的后半部分适用于子程序的结尾，因此通常被称为定义子程序的结尾。
